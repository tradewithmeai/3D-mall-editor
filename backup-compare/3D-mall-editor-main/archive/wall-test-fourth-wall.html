<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fourth Wall Test - Isolate the Killer</title>
    <style>
        body { margin: 0; padding: 0; background: #000; font-family: monospace; }
        #status {
            position: absolute; 
            top: 10px; 
            right: 10px; 
            color: #0f0;
            background: rgba(0,0,0,0.9); 
            padding: 15px; 
            border-radius: 5px;
            max-width: 350px; 
            max-height: 80vh;
            overflow-y: auto;
            font-size: 11px;
            z-index: 1000;
        }
        .wall-info {
            color: #ff4;
            background: rgba(255,255,0,0.1);
            padding: 2px 4px;
            margin: 2px 0;
            border-left: 3px solid #ff0;
        }
        .error {
            color: #f44;
            background: rgba(255,0,0,0.1);
            padding: 2px 4px;
            margin: 2px 0;
            border-left: 3px solid #f44;
        }
    </style>
</head>
<body>
    <div id="status"><strong>üéØ Fourth Wall Test - Find the Killer</strong></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const status = document.getElementById('status');
        
        function updateStatus(msg, type = 'normal') {
            const div = document.createElement('div');
            if (type === 'wall') div.className = 'wall-info';
            else if (type === 'error') div.className = 'error';
            div.innerHTML = `[${new Date().toLocaleTimeString()}] ${msg}`;
            status.appendChild(div);
            status.scrollTop = status.scrollHeight;
            console.log(`[FOURTH-WALL-TEST] ${msg}`);
        }
        
        // Enhanced error catching
        window.addEventListener('error', (e) => {
            updateStatus(`‚ùå JS ERROR: ${e.message} at ${e.filename}:${e.lineno}`, 'error');
        });
        
        window.addEventListener('unhandledrejection', (e) => {
            updateStatus(`‚ùå PROMISE ERROR: ${e.reason}`, 'error');
        });
        
        // EXACT same setup as working 3-wall test
        const EMBEDDED_COMPONENTS = {
            "components": {
                "referencePole": {
                    "model": "cylinder",
                    "size": [0.1, 0.1, 1, 8],
                    "material": {
                        "type": "MeshBasicMaterial",
                        "color": "#000000"
                    }
                },
                "floor": {
                    "model": "plane",
                    "size": [20, 20],
                    "rotation": [-1.5707963267948966, 0, 0],
                    "material": {
                        "type": "MeshStandardMaterial",
                        "color": "#90EE90",
                        "roughness": 0.6,
                        "metalness": 0.1
                    }
                },
                "wall": {
                    "model": "plane",
                    "size": [20, 8],
                    "material": {
                        "type": "MeshStandardMaterial",
                        "color": "#ffffff",
                        "roughness": 0.8,
                        "metalness": 0.0
                    }
                }
            }
        };

        // Same factory with memory monitoring
        class TestFactory {
            constructor() {
                this.registry = EMBEDDED_COMPONENTS;
                this.wallCount = 0;
                this.createdMeshes = [];
                updateStatus('Factory constructor completed');
            }
            
            createMaterial(materialConfig) {
                try {
                    updateStatus(`Creating material: ${materialConfig.type}`);
                    
                    const MaterialClass = materialConfig.type === 'MeshBasicMaterial' ? 
                        THREE.MeshBasicMaterial : THREE.MeshStandardMaterial;
                    
                    const params = {};
                    Object.entries(materialConfig).forEach(([key, value]) => {
                        if (key === 'type') return;
                        if (key === 'color') {
                            params[key] = new THREE.Color(value);
                            updateStatus(`Material color: ${value} -> #${params[key].getHexString()}`);
                        } else {
                            params[key] = value;
                        }
                    });
                    
                    const material = new MaterialClass(params);
                    updateStatus(`‚úÖ Material created: ${material.constructor.name}`);
                    return material;
                    
                } catch (error) {
                    updateStatus(`‚ùå Material creation error: ${error.message}`, 'error');
                    throw error;
                }
            }
            
            createGeometry(type, dimensions) {
                try {
                    updateStatus(`Creating geometry: ${type} [${dimensions.join(',')}]`);
                    
                    let geometry;
                    switch (type) {
                        case 'cylinder': geometry = new THREE.CylinderGeometry(...dimensions); break;
                        case 'plane': geometry = new THREE.PlaneGeometry(...dimensions); break;
                        default: geometry = new THREE.BoxGeometry(1, 1, 1); break;
                    }
                    
                    updateStatus(`‚úÖ Geometry created: ${geometry.constructor.name}`);
                    return geometry;
                    
                } catch (error) {
                    updateStatus(`‚ùå Geometry creation error: ${error.message}`, 'error');
                    throw error;
                }
            }
            
            createComponent(componentType, config, scene) {
                try {
                    updateStatus(`--- CREATING ${componentType.toUpperCase()} #${this.createdMeshes.length + 1} ---`);
                    
                    const componentDef = this.registry.components[componentType];
                    if (!componentDef) {
                        throw new Error(`Unknown component: ${componentType}`);
                    }
                    
                    const geometry = this.createGeometry(componentDef.model, componentDef.size);
                    const material = this.createMaterial(componentDef.material);
                    
                    updateStatus(`Creating mesh...`);
                    const mesh = new THREE.Mesh(geometry, material);
                    
                    if (config.position) {
                        updateStatus(`Setting position: [${config.position.join(',')}]`);
                        mesh.position.set(...config.position);
                    }
                    
                    if (config.rotation) {
                        updateStatus(`Setting rotation: [${config.rotation.join(',')}]`);
                        updateStatus(`Rotation analysis: ${config.rotation[1]} radians = ${config.rotation[1] * (180/Math.PI)}¬∞`);
                        mesh.rotation.set(...config.rotation);
                    }
                    
                    if (componentDef.rotation) {
                        updateStatus(`Applying component rotation: [${componentDef.rotation.join(',')}]`);
                        mesh.rotation.set(...componentDef.rotation);
                    }
                    
                    // Track walls specifically
                    if (componentType === 'wall') {
                        this.wallCount++;
                        const color = mesh.material.color.getHexString();
                        updateStatus(`WALL #${this.wallCount}: color=#${color}`, 'wall');
                    }
                    
                    updateStatus(`Adding to scene... (Current objects: ${this.createdMeshes.length})`);
                    scene.add(mesh);
                    this.createdMeshes.push(mesh);
                    
                    updateStatus(`‚úÖ ${componentType} created successfully (Total: ${this.createdMeshes.length})`);
                    return mesh;
                    
                } catch (error) {
                    updateStatus(`‚ùå Component creation error: ${error.message}`, 'error');
                    updateStatus(`‚ùå Stack: ${error.stack}`, 'error');
                    throw error;
                }
            }
        }
        
        function initTest() {
            try {
                updateStatus('üéØ Starting FOURTH wall test - ISOLATE THE KILLER...', 'wall');
                
                updateStatus('Creating scene...');
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0xf5f5f5);
                updateStatus('‚úÖ Scene created');
                
                updateStatus('Creating camera...');
                const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(0, 2, 8);
                updateStatus('‚úÖ Camera created');
                
                updateStatus('Creating renderer...');
                const renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                document.body.appendChild(renderer.domElement);
                updateStatus('‚úÖ Renderer created and appended');
                
                updateStatus('Adding lighting...');
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
                scene.add(ambientLight);
                updateStatus('‚úÖ Lighting added');
                
                updateStatus('Creating factory...');
                const factory = new TestFactory();
                updateStatus('‚úÖ Factory ready');
                
                // Create base objects first (EXACT same as working 3-wall test)
                updateStatus('Creating reference pole...');
                factory.createComponent('referencePole', { position: [0, 0.5, 0] }, scene);
                
                updateStatus('Creating floor...');
                factory.createComponent('floor', { position: [0, 0, 0] }, scene);
                
                // Create first 3 walls (EXACT same as working test)
                updateStatus('Creating FIRST wall (front)...');
                factory.createComponent('wall', { position: [0, 4, -10] }, scene);
                
                updateStatus('Creating SECOND wall (back)...');
                factory.createComponent('wall', { position: [0, 4, 10], rotation: [0, Math.PI, 0] }, scene);
                
                updateStatus('Creating THIRD wall (left)...');
                factory.createComponent('wall', { position: [-10, 4, 0], rotation: [0, Math.PI/2, 0] }, scene);
                
                updateStatus('üõë ABOUT TO CREATE THE KILLER FOURTH WALL...', 'wall');
                updateStatus('üß™ Testing the suspected culprit: [10, 4, 0] with rotation [0, -Math.PI/2, 0]', 'wall');
                
                // THE KILLER FOURTH WALL - this is what causes the crash
                factory.createComponent('wall', { position: [10, 4, 0], rotation: [0, -Math.PI/2, 0] }, scene);
                
                updateStatus(`üéâ MIRACLE: Created ${factory.wallCount} walls without crash!`, 'wall');
                updateStatus(`Total scene objects: ${factory.createdMeshes.length}`, 'wall');
                
                updateStatus('Attempting render...');
                renderer.render(scene, camera);
                updateStatus('‚úÖ Render complete!');
                
                // Simple animation
                function animate() {
                    requestAnimationFrame(animate);
                    renderer.render(scene, camera);
                }
                animate();
                
            } catch (error) {
                updateStatus(`üí• KILLER IDENTIFIED: ${error.message}`, 'error');
                updateStatus(`üí• Stack: ${error.stack}`, 'error');
                updateStatus(`üí• This is the exact line that kills the application!`, 'error');
            }
        }
        
        // Initialize
        setTimeout(() => {
            try {
                if (typeof THREE !== 'undefined') {
                    updateStatus(`THREE.js loaded (r${THREE.REVISION})`);
                    initTest();
                } else {
                    updateStatus('‚ùå THREE.js failed to load', 'error');
                }
            } catch (error) {
                updateStatus(`üí• Initialization error: ${error.message}`, 'error');
            }
        }, 1000);
        
    </script>
</body>
</html>