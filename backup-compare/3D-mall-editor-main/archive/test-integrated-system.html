<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Integration Test - Quick Validation</title>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background: #000; font-family: monospace; }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #0f0;
            background: rgba(0,0,0,0.9);
            padding: 15px;
            border-radius: 5px;
            max-width: 400px;
            font-size: 12px;
        }
        #status {
            position: absolute;
            top: 10px;
            right: 10px;
            color: #0f0;
            background: rgba(0,0,0,0.9);
            padding: 15px;
            border-radius: 5px;
            max-width: 300px;
            font-size: 11px;
            max-height: 400px;
            overflow-y: auto;
        }
        .test-result {
            margin: 5px 0;
            padding: 3px 6px;
            border-radius: 3px;
        }
        .pass { background: rgba(0, 255, 0, 0.2); border-left: 3px solid #0f0; }
        .fail { background: rgba(255, 0, 0, 0.2); border-left: 3px solid #f00; }
        .info { background: rgba(0, 150, 255, 0.2); border-left: 3px solid #09f; }
    </style>
</head>
<body>
    <div id="info">
        <h3>üß™ Integration Test Suite</h3>
        <p><strong>Testing:</strong> Factory system integration with main application</p>
        <p><strong>Auto-running tests:</strong></p>
        <ul>
            <li>THREE.js loading</li>
            <li>Factory system initialization</li>
            <li>Room creation from JSON</li>
            <li>Diana AI system</li>
            <li>Component creation/modification</li>
            <li>Player movement integration</li>
        </ul>
        <p><strong>Manual tests:</strong> WASD movement, mouse look, debug ball kick</p>
    </div>
    
    <div id="status">
        <h4>Test Results</h4>
        <div id="test-log"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Copy the integrated system's core components for testing
        const EMBEDDED_COMPONENTS = {
            "components": {
                "referencePole": {
                    "model": "cylinder",
                    "size": [0.1, 0.1, 1, 8],
                    "material": { "type": "MeshBasicMaterial", "color": "#000000" },
                    "collision": false,
                    "agentEditable": { "color": true }
                },
                "debugBall": {
                    "model": "sphere",
                    "size": [0.3, 16, 16],
                    "material": {
                        "type": "MeshStandardMaterial", "color": "#44ff44",
                        "roughness": 0.3, "metalness": 0.2, "transparent": true, "opacity": 0.8,
                        "emissive": "#114411", "emissiveIntensity": 0.2
                    },
                    "collision": true,
                    "agentEditable": { "color": true, "emissive": true }
                },
                "floor": {
                    "model": "plane", "size": [40, 30], "rotation": [-1.5707963267948966, 0, 0],
                    "material": { "type": "MeshStandardMaterial", "color": "#90EE90", "roughness": 0.6, "metalness": 0.1 },
                    "collision": false,
                    "agentEditable": { "color": true, "roughness": true, "metalness": true }
                },
                "wall": {
                    "model": "plane", "size": [40, 8],
                    "material": { "type": "MeshStandardMaterial", "color": "#f8f8f8", "roughness": 0.9, "metalness": 0.1 },
                    "collision": true,
                    "agentEditable": { "color": true, "roughness": true, "metalness": true }
                }
            }
        };

        const EMBEDDED_LAYOUT = {
            "metadata": { "version": "1.0", "coordinateSystem": "corner-based", "origin": "Southwest corner (0,0,0)",
                "dimensions": { "width": 40, "depth": 30, "height": 8 } },
            "player": { "startPosition": [20, 1.6, 15], "movement": { "baseSpeed": 0.15, "maxSpeed": 0.6 } },
            "objects": [
                { "type": "referencePole", "id": "origin-pole", "position": [0, 0.5, 0], "properties": { "compass": "origin" } },
                { "type": "debugBall", "id": "debug-ball", "position": [37, 0.3, 27], "properties": { "compass": "northeast" } },
                { "type": "floor", "id": "main-floor", "position": [20, 0, 15], "properties": { "compass": "center" } },
                { "type": "wall", "id": "north-wall", "position": [20, 4, 30], "rotation": [0, 0, 0], "properties": { "compass": "north" } },
                { "type": "wall", "id": "south-wall", "position": [20, 4, 0], "rotation": [0, Math.PI, 0], "properties": { "compass": "south" } },
                { "type": "wall", "id": "east-wall", "position": [40, 4, 15], "rotation": [0, -Math.PI/2, 0], "size": [30, 8], "properties": { "compass": "east" } },
                { "type": "wall", "id": "west-wall", "position": [0, 4, 15], "rotation": [0, Math.PI/2, 0], "size": [30, 8], "properties": { "compass": "west" } }
            ]
        };

        // Simplified versions of the classes for testing
        class TestComponentFactory {
            constructor() {
                this.registry = EMBEDDED_COMPONENTS;
                this.createdObjects = new Map();
                this.objectCounter = 0;
            }
            
            createMaterial(materialConfig) {
                const materialTypes = {
                    'MeshStandardMaterial': THREE.MeshStandardMaterial,
                    'MeshBasicMaterial': THREE.MeshBasicMaterial
                };
                
                const MaterialClass = materialTypes[materialConfig.type] || THREE.MeshStandardMaterial;
                const params = {};
                
                Object.entries(materialConfig).forEach(([key, value]) => {
                    if (key === 'type') return;
                    if (key === 'color' || key === 'emissive') {
                        if (typeof value === 'string' && value.startsWith('#')) {
                            params[key] = new THREE.Color(value);
                        } else {
                            params[key] = value;
                        }
                    } else {
                        params[key] = value;
                    }
                });
                
                return new MaterialClass(params);
            }
            
            createGeometry(type, dimensions) {
                switch (type) {
                    case 'box': return new THREE.BoxGeometry(...dimensions);
                    case 'cylinder': return new THREE.CylinderGeometry(...dimensions);
                    case 'sphere': return new THREE.SphereGeometry(...dimensions);
                    case 'plane': return new THREE.PlaneGeometry(...dimensions);
                    default: return new THREE.BoxGeometry(1, 1, 1);
                }
            }
            
            createComponent(componentType, config, scene) {
                const componentDef = this.registry.components[componentType];
                if (!componentDef) return null;
                
                const size = config.size || componentDef.size;
                const geometry = this.createGeometry(componentDef.model, size);
                
                const materialConfig = config.material || componentDef.material;
                const material = this.createMaterial(materialConfig);
                
                const mesh = new THREE.Mesh(geometry, material);
                
                if (config.position) mesh.position.set(...config.position);
                if (componentDef.rotation) mesh.rotation.set(...componentDef.rotation);
                if (config.rotation) mesh.rotation.set(...config.rotation);
                
                const uniqueId = config.id || `${componentType}-${++this.objectCounter}`;
                mesh.userData = {
                    componentType: componentType,
                    compass: config.properties?.compass || null,
                    id: uniqueId,
                    isFactoryCreated: true
                };
                
                scene.add(mesh);
                this.createdObjects.set(uniqueId, mesh);
                return mesh;
            }
            
            buildRoomFromLayout(layout, scene) {
                window.LOBBY_WIDTH = layout.metadata.dimensions.width;
                window.LOBBY_DEPTH = layout.metadata.dimensions.depth;
                window.LOBBY_HEIGHT = layout.metadata.dimensions.height;
                
                layout.objects.forEach(obj => {
                    this.createComponent(obj.type, obj, scene);
                });
                
                return true;
            }
            
            findObject(identifier) {
                if (this.createdObjects.has(identifier)) {
                    return this.createdObjects.get(identifier);
                }
                
                for (const [id, mesh] of this.createdObjects) {
                    if (mesh.userData.compass === identifier || mesh.userData.id === identifier) {
                        return mesh;
                    }
                }
                return null;
            }
        }

        // Test infrastructure
        const testLog = document.getElementById('test-log');
        let testsPassed = 0;
        let testsFailed = 0;
        
        function logTest(message, passed, details = '') {
            const div = document.createElement('div');
            div.className = `test-result ${passed ? 'pass' : 'fail'}`;
            div.innerHTML = `${passed ? '‚úÖ' : '‚ùå'} ${message}`;
            if (details) {
                div.innerHTML += `<br><small>${details}</small>`;
            }
            testLog.appendChild(div);
            
            if (passed) testsPassed++;
            else testsFailed++;
        }
        
        function logInfo(message) {
            const div = document.createElement('div');
            div.className = 'test-result info';
            div.innerHTML = `‚ÑπÔ∏è ${message}`;
            testLog.appendChild(div);
        }
        
        // Test suite
        async function runTests() {
            logInfo('Starting integration test suite...');
            
            // Test 1: THREE.js loading
            try {
                if (typeof THREE !== 'undefined') {
                    logTest(`THREE.js loaded (r${THREE.REVISION})`, true);
                } else {
                    logTest('THREE.js loading', false, 'THREE object not found');
                    return;
                }
            } catch (error) {
                logTest('THREE.js loading', false, error.message);
                return;
            }
            
            // Test 2: Scene creation
            let scene, camera, renderer;
            try {
                scene = new THREE.Scene();
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                renderer = new THREE.WebGLRenderer();
                renderer.setSize(400, 300); // Small size for testing
                document.body.appendChild(renderer.domElement);
                logTest('Scene initialization', true, 'Scene, camera, renderer created');
            } catch (error) {
                logTest('Scene initialization', false, error.message);
                return;
            }
            
            // Test 3: Component factory creation
            let factory;
            try {
                factory = new TestComponentFactory();
                logTest('ComponentFactory creation', true, `Registry contains ${Object.keys(factory.registry.components).length} component types`);
            } catch (error) {
                logTest('ComponentFactory creation', false, error.message);
                return;
            }
            
            // Test 4: Individual component creation
            try {
                const pole = factory.createComponent('referencePole', { id: 'test-pole', position: [0, 0.5, 0] }, scene);
                if (pole && pole.userData.id === 'test-pole') {
                    logTest('Reference pole creation', true, `Position: [${pole.position.toArray().map(n => n.toFixed(1)).join(', ')}]`);
                } else {
                    logTest('Reference pole creation', false, 'Failed to create or set userData');
                }
            } catch (error) {
                logTest('Reference pole creation', false, error.message);
            }
            
            // Test 5: Debug ball creation with material properties
            try {
                const ball = factory.createComponent('debugBall', { id: 'test-ball', position: [2, 0.3, 2] }, scene);
                if (ball && ball.material.color.getHex() !== 0xffffff) {
                    logTest('Debug ball material', true, `Color: #${ball.material.color.getHexString()}`);
                } else {
                    logTest('Debug ball material', false, 'Material color not applied correctly');
                }
            } catch (error) {
                logTest('Debug ball material', false, error.message);
            }
            
            // Test 6: Room building from layout
            try {
                const success = factory.buildRoomFromLayout(EMBEDDED_LAYOUT, scene);
                const objectCount = factory.createdObjects.size;
                if (success && objectCount > 0) {
                    logTest('Room from layout', true, `Created ${objectCount} objects from JSON layout`);
                } else {
                    logTest('Room from layout', false, `Objects created: ${objectCount}`);
                }
            } catch (error) {
                logTest('Room from layout', false, error.message);
            }
            
            // Test 7: Object finding system
            try {
                const northWall = factory.findObject('north-wall');
                const compassWall = factory.findObject('north');
                if (northWall && northWall.userData.compass === 'north') {
                    logTest('Object finding (ID)', true, `Found north-wall at [${northWall.position.toArray().map(n => n.toFixed(1)).join(', ')}]`);
                } else {
                    logTest('Object finding (ID)', false, 'Could not find north-wall by ID');
                }
            } catch (error) {
                logTest('Object finding (ID)', false, error.message);
            }
            
            // Test 8: Global dimensions setting
            try {
                if (window.LOBBY_WIDTH === 40 && window.LOBBY_DEPTH === 30 && window.LOBBY_HEIGHT === 8) {
                    logTest('Global dimensions', true, `${window.LOBBY_WIDTH}√ó${window.LOBBY_DEPTH}√ó${window.LOBBY_HEIGHT}`);
                } else {
                    logTest('Global dimensions', false, `Expected 40√ó30√ó8, got ${window.LOBBY_WIDTH}√ó${window.LOBBY_DEPTH}√ó${window.LOBBY_HEIGHT}`);
                }
            } catch (error) {
                logTest('Global dimensions', false, error.message);
            }
            
            // Test 9: Render test
            try {
                renderer.render(scene, camera);
                logTest('Rendering test', true, 'Scene rendered without errors');
            } catch (error) {
                logTest('Rendering test', false, error.message);
            }
            
            // Final summary
            logInfo('=== TEST SUMMARY ===');
            logInfo(`‚úÖ Passed: ${testsPassed}`);
            logInfo(`‚ùå Failed: ${testsFailed}`);
            logInfo(`üìä Success Rate: ${Math.round((testsPassed / (testsPassed + testsFailed)) * 100)}%`);
            
            if (testsFailed === 0) {
                logInfo('üéâ ALL TESTS PASSED - Integration ready for deployment!');
            } else {
                logInfo('‚ö†Ô∏è Some tests failed - review before deployment');
            }
        }
        
        // Run tests when THREE.js loads
        setTimeout(() => {
            runTests();
        }, 1000);
    </script>
</body>
</html>