<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Edge Cases Test - Step 5E: Error Handling & Performance</title>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background: #000; font-family: monospace; }
        #info {
            position: absolute;
            top: 10px;
            right: 10px;
            color: #0f0;
            background: rgba(0,0,0,0.9);
            padding: 10px;
            border-radius: 5px;
            max-width: 420px;
            max-height: 400px;
            overflow-y: auto;
            font-size: 9px;
        }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #0f0;
            background: rgba(0,0,0,0.9);
            padding: 15px;
            border-radius: 5px;
            font-size: 10px;
            max-width: 380px;
        }
        .btn-group {
            margin: 8px 0;
            border-top: 1px solid #333;
            padding-top: 5px;
        }
        .btn {
            background: #333;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 4px 8px;
            margin: 2px;
            border-radius: 3px;
            cursor: pointer;
            font-family: monospace;
            font-size: 9px;
        }
        .btn:hover { background: #0f0; color: #000; }
        .btn.stress { border-color: #f44; color: #f44; }
        .btn.stress:hover { background: #f44; color: #fff; }
        .btn.memory { border-color: #44f; color: #44f; }
        .btn.memory:hover { background: #44f; color: #fff; }
        .btn.error { border-color: #fa0; color: #fa0; }
        .btn.error:hover { background: #fa0; color: #000; }
        #toggle-info {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0,0,0,0.8);
            color: #0f0;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 10px;
        }
        .performance-info {
            background: rgba(0, 40, 40, 0.4);
            border-left: 3px solid #4ff;
            padding: 5px;
            margin: 5px 0;
            font-family: monospace;
            font-size: 8px;
        }
        .error-info {
            background: rgba(60, 20, 0, 0.4);
            border-left: 3px solid #f84;
            padding: 5px;
            margin: 5px 0;
            font-family: monospace;
            font-size: 8px;
        }
        .success-info {
            background: rgba(0, 40, 0, 0.4);
            border-left: 3px solid #4f4;
            padding: 5px;
            margin: 5px 0;
            font-family: monospace;
            font-size: 8px;
        }
    </style>
</head>
<body>
    <div id="controls">
        <h3>‚ö†Ô∏è Edge Cases & Error Handling</h3>
        
        <div class="btn-group">
            <strong>Stress Tests:</strong><br>
            <button class="btn stress" onclick="stressTestMany()">Add 50 Objects</button>
            <button class="btn stress" onclick="stressTestRapid()">Rapid Commands</button><br>
            <button class="btn stress" onclick="stressTestMemory()">Memory Overload</button>
            <button class="btn stress" onclick="stressTestConcurrent()">Concurrent Ops</button>
        </div>
        
        <div class="btn-group">
            <strong>Memory Management:</strong><br>
            <button class="btn memory" onclick="testMemoryLeaks()">Test Memory Leaks</button>
            <button class="btn memory" onclick="testGarbageCollection()">Force GC</button><br>
            <button class="btn memory" onclick="testLargeObjects()">Large Objects</button>
            <button class="btn memory" onclick="cleanupTest()">Cleanup Test</button>
        </div>
        
        <div class="btn-group">
            <strong>Error Conditions:</strong><br>
            <button class="btn error" onclick="testInvalidCommands()">Invalid Commands</button>
            <button class="btn error" onclick="testMissingObjects()">Missing Objects</button><br>
            <button class="btn error" onclick="testCorruptedData()">Corrupted Data</button>
            <button class="btn error" onclick="testBoundaryValues()">Boundary Values</button>
        </div>
        
        <div class="btn-group">
            <strong>Performance Tests:</strong><br>
            <button class="btn" onclick="benchmarkOperations()">Benchmark Ops</button>
            <button class="btn" onclick="profileRendering()">Profile Rendering</button><br>
            <button class="btn" onclick="testScalability()">Scalability Test</button>
            <button class="btn" onclick="measureLatency()">Measure Latency</button>
        </div>
        
        <div class="btn-group">
            <strong>Recovery & Validation:</strong><br>
            <button class="btn" onclick="testStateRecovery()">State Recovery</button>
            <button class="btn" onclick="validateIntegrity()">Validate Integrity</button><br>
            <button class="btn" onclick="testRollback()">Test Rollback</button>
            <button class="btn" onclick="emergencyCleanup()">Emergency Cleanup</button>
        </div>
        
        <div class="btn-group">
            <button class="btn" onclick="resetEverything()">üîÑ Reset Everything</button>
            <button class="btn" onclick="generateReport()">üìä Generate Report</button>
        </div>
    </div>

    <div id="toggle-info" onclick="toggleInfo()">HIDE INFO</div>
    <div id="info">
        <h3>‚ö†Ô∏è Edge Cases & Performance Testing</h3>
        <div id="status">Loading...</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Extended component definitions for stress testing
        const EMBEDDED_COMPONENTS = {
            "components": {
                "referencePole": {
                    "model": "cylinder", "size": [0.1, 0.1, 1, 8],
                    "material": { "type": "MeshBasicMaterial", "color": "#000000" },
                    "properties": { "castShadow": false, "receiveShadow": false }
                },
                "debugBall": {
                    "model": "sphere", "size": [0.3, 16, 16],
                    "material": {
                        "type": "MeshStandardMaterial", "color": "#44ff44", "roughness": 0.3,
                        "metalness": 0.2, "transparent": true, "opacity": 0.8,
                        "emissive": "#114411", "emissiveIntensity": 0.2
                    },
                    "properties": { "castShadow": true, "receiveShadow": true }
                },
                "floor": {
                    "model": "plane", "size": [10, 8], "rotation": [-1.5707963267948966, 0, 0],
                    "material": { "type": "MeshStandardMaterial", "color": "#90EE90", "roughness": 0.6, "metalness": 0.1 },
                    "properties": { "receiveShadow": true }
                },
                "wall": {
                    "model": "plane", "size": [10, 8],
                    "material": { "type": "MeshStandardMaterial", "color": "#f8f8f8", "roughness": 0.9, "metalness": 0.1 },
                    "properties": { "castShadow": false, "receiveShadow": true }
                },
                // Test objects for stress testing
                "cube": {
                    "model": "box", "size": [0.5, 0.5, 0.5],
                    "material": { "type": "MeshStandardMaterial", "color": "#ff4444", "roughness": 0.5, "metalness": 0.3 },
                    "properties": { "castShadow": true, "receiveShadow": true }
                },
                "sphere": {
                    "model": "sphere", "size": [0.3, 8, 8],
                    "material": { "type": "MeshStandardMaterial", "color": "#4444ff", "roughness": 0.4, "metalness": 0.2 },
                    "properties": { "castShadow": true, "receiveShadow": true }
                },
                "cylinder": {
                    "model": "cylinder", "size": [0.2, 0.2, 0.8, 8],
                    "material": { "type": "MeshStandardMaterial", "color": "#44ff44", "roughness": 0.6, "metalness": 0.1 },
                    "properties": { "castShadow": true, "receiveShadow": true }
                }
            }
        };

        // Robust factory with error handling and performance monitoring
        class RobustFactory {
            constructor() {
                this.registry = EMBEDDED_COMPONENTS;
                this.createdObjects = new Map();
                this.addedItems = new Map();
                this.operationHistory = [];
                this.nextId = 1;
                this.performanceMetrics = {
                    creationTimes: [],
                    removalTimes: [],
                    memoryUsage: [],
                    errorCount: 0,
                    operationCount: 0
                };
            }
            
            createMaterial(materialConfig) {
                try {
                    const materialTypes = {
                        'MeshStandardMaterial': THREE.MeshStandardMaterial,
                        'MeshBasicMaterial': THREE.MeshBasicMaterial
                    };
                    
                    const MaterialClass = materialTypes[materialConfig.type] || THREE.MeshStandardMaterial;
                    const params = {};
                    
                    Object.entries(materialConfig).forEach(([key, value]) => {
                        if (key === 'type') return;
                        
                        try {
                            if (key === 'color' || key === 'emissive') {
                                if (typeof value === 'string' && value.startsWith('#')) {
                                    params[key] = new THREE.Color(value);
                                } else {
                                    params[key] = value;
                                }
                            } else {
                                // Validate numeric values
                                if (typeof value === 'number') {
                                    if (isNaN(value) || !isFinite(value)) {
                                        logError(`Invalid numeric value for ${key}: ${value}`);
                                        return; // Skip this property
                                    }
                                }
                                params[key] = value;
                            }
                        } catch (propError) {
                            logError(`Error setting material property ${key}: ${propError.message}`);
                        }
                    });
                    
                    return new MaterialClass(params);
                } catch (error) {
                    logError(`Material creation failed: ${error.message}`);
                    // Return fallback material
                    return new THREE.MeshBasicMaterial({ color: 0xff00ff }); // Magenta = error material
                }
            }
            
            createGeometry(type, dimensions) {
                try {
                    // Validate dimensions
                    if (!Array.isArray(dimensions)) {
                        logError(`Invalid dimensions for ${type}: not an array`);
                        return new THREE.BoxGeometry(1, 1, 1); // Fallback
                    }
                    
                    // Check for invalid values in dimensions
                    for (let i = 0; i < dimensions.length; i++) {
                        if (typeof dimensions[i] !== 'number' || isNaN(dimensions[i]) || dimensions[i] <= 0) {
                            logError(`Invalid dimension [${i}] for ${type}: ${dimensions[i]}`);
                            dimensions[i] = 1; // Fix invalid dimension
                        }
                        
                        // Prevent extremely large geometries
                        if (dimensions[i] > 1000) {
                            logError(`Dimension too large [${i}] for ${type}: ${dimensions[i]}, clamping to 1000`);
                            dimensions[i] = 1000;
                        }
                    }
                    
                    switch (type) {
                        case 'cylinder':
                            return new THREE.CylinderGeometry(...dimensions);
                        case 'sphere':
                            return new THREE.SphereGeometry(...dimensions);
                        case 'plane':
                            return new THREE.PlaneGeometry(...dimensions);
                        case 'box':
                            return new THREE.BoxGeometry(...dimensions);
                        default:
                            logError(`Unknown geometry type: ${type}`);
                            return new THREE.BoxGeometry(1, 1, 1);
                    }
                } catch (error) {
                    logError(`Geometry creation failed for ${type}: ${error.message}`);
                    return new THREE.BoxGeometry(1, 1, 1); // Fallback geometry
                }
            }
            
            addComponent(componentType, options = {}) {
                const startTime = performance.now();
                this.performanceMetrics.operationCount++;
                
                try {
                    const scene = options.scene || window.scene;
                    if (!scene) {
                        throw new Error('No scene available');
                    }
                    
                    const componentDef = this.registry.components[componentType];
                    if (!componentDef) {
                        throw new Error(`Component type '${componentType}' not found`);
                    }
                    
                    // Validate position
                    let position = options.position;
                    if (!position) {
                        position = this.generateSafePosition(componentType);
                    } else {
                        position = this.validatePosition(position);
                    }
                    
                    // Create geometry and material with error handling
                    const geometry = this.createGeometry(componentDef.model, componentDef.size);
                    const material = this.createMaterial(componentDef.material);
                    
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.position.set(...position);
                    
                    if (componentDef.rotation) {
                        mesh.rotation.set(...componentDef.rotation);
                    }
                    
                    if (componentDef.properties) {
                        Object.entries(componentDef.properties).forEach(([prop, value]) => {
                            try {
                                mesh[prop] = value;
                            } catch (propError) {
                                logError(`Error setting property ${prop}: ${propError.message}`);
                            }
                        });
                    }
                    
                    const uniqueId = `${componentType}-${this.nextId++}`;
                    mesh.userData = {
                        componentType: componentType,
                        id: uniqueId,
                        createdBy: 'RobustFactory',
                        createdAt: Date.now(),
                        isAdded: true
                    };
                    
                    scene.add(mesh);
                    this.createdObjects.set(uniqueId, mesh);
                    this.addedItems.set(uniqueId, mesh);
                    
                    // Record performance
                    const elapsed = performance.now() - startTime;
                    this.performanceMetrics.creationTimes.push(elapsed);
                    
                    // Record operation
                    this.operationHistory.push({
                        type: 'add',
                        componentType: componentType,
                        id: uniqueId,
                        timestamp: Date.now(),
                        duration: elapsed
                    });
                    
                    logSuccess(`Added ${componentType} in ${elapsed.toFixed(2)}ms`);
                    return mesh;
                    
                } catch (error) {
                    this.performanceMetrics.errorCount++;
                    logError(`Failed to add ${componentType}: ${error.message}`);
                    return null;
                }
            }
            
            removeComponent(identifier, scene) {
                const startTime = performance.now();
                this.performanceMetrics.operationCount++;
                
                try {
                    const mesh = this.findObject(identifier);
                    if (!mesh) {
                        throw new Error(`Object '${identifier}' not found`);
                    }
                    
                    // Safe disposal
                    this.safeDispose(mesh);
                    scene.remove(mesh);
                    
                    // Remove from tracking
                    for (let [key, value] of this.createdObjects) {
                        if (value === mesh) {
                            this.createdObjects.delete(key);
                            break;
                        }
                    }
                    
                    for (let [key, value] of this.addedItems) {
                        if (value === mesh) {
                            this.addedItems.delete(key);
                            break;
                        }
                    }
                    
                    // Record performance
                    const elapsed = performance.now() - startTime;
                    this.performanceMetrics.removalTimes.push(elapsed);
                    
                    this.operationHistory.push({
                        type: 'remove',
                        identifier: identifier,
                        timestamp: Date.now(),
                        duration: elapsed
                    });
                    
                    logSuccess(`Removed ${identifier} in ${elapsed.toFixed(2)}ms`);
                    return true;
                    
                } catch (error) {
                    this.performanceMetrics.errorCount++;
                    logError(`Failed to remove ${identifier}: ${error.message}`);
                    return false;
                }
            }
            
            safeDispose(mesh) {
                try {
                    if (mesh.geometry && mesh.geometry.dispose) {
                        mesh.geometry.dispose();
                    }
                    
                    if (mesh.material) {
                        if (Array.isArray(mesh.material)) {
                            mesh.material.forEach(mat => {
                                if (mat.dispose) mat.dispose();
                            });
                        } else if (mesh.material.dispose) {
                            mesh.material.dispose();
                        }
                    }
                } catch (error) {
                    logError(`Disposal error: ${error.message}`);
                }
            }
            
            validatePosition(position) {
                if (!Array.isArray(position) || position.length !== 3) {
                    logError(`Invalid position format: ${position}, using default`);
                    return [0, 0.5, 0];
                }
                
                return position.map((coord, index) => {
                    if (typeof coord !== 'number' || isNaN(coord) || !isFinite(coord)) {
                        logError(`Invalid coordinate [${index}]: ${coord}, using 0`);
                        return 0;
                    }
                    
                    // Clamp to reasonable bounds
                    if (Math.abs(coord) > 100) {
                        logError(`Coordinate [${index}] too large: ${coord}, clamping`);
                        return Math.sign(coord) * 100;
                    }
                    
                    return coord;
                });
            }
            
            generateSafePosition(componentType) {
                // Generate positions within safe bounds
                const x = (Math.random() - 0.5) * 8; // -4 to 4
                const z = (Math.random() - 0.5) * 6; // -3 to 3
                const y = Math.max(0.1, Math.random() * 2); // 0.1 to 2
                
                return [x, y, z];
            }
            
            setColor(identifier, color) {
                try {
                    const mesh = this.findObject(identifier);
                    if (!mesh || !mesh.material) {
                        throw new Error(`Object or material not found for ${identifier}`);
                    }
                    
                    if (typeof color === 'string' && color.startsWith('#')) {
                        mesh.material.color = new THREE.Color(color);
                    } else {
                        mesh.material.color = color;
                    }
                    
                    mesh.material.needsUpdate = true;
                    return true;
                } catch (error) {
                    logError(`Color change failed for ${identifier}: ${error.message}`);
                    return false;
                }
            }
            
            findObject(identifier) {
                try {
                    // Direct ID lookup
                    for (let [key, mesh] of this.createdObjects) {
                        if (key === identifier || mesh.userData.id === identifier) {
                            return mesh;
                        }
                    }
                    
                    // Semantic lookup
                    const semanticMap = {
                        'floor': (obj) => obj.userData.componentType === 'floor',
                        'north-wall': (obj) => obj.userData.componentType === 'wall' && obj.userData.compass === 'north',
                        'south-wall': (obj) => obj.userData.componentType === 'wall' && obj.userData.compass === 'south',
                        'east-wall': (obj) => obj.userData.componentType === 'wall' && obj.userData.compass === 'east',
                        'west-wall': (obj) => obj.userData.componentType === 'wall' && obj.userData.compass === 'west',
                        'referencePole': (obj) => obj.userData.componentType === 'referencePole',
                        'debugBall': (obj) => obj.userData.componentType === 'debugBall'
                    };
                    
                    if (semanticMap[identifier]) {
                        for (let [key, mesh] of this.createdObjects) {
                            if (semanticMap[identifier](mesh)) {
                                return mesh;
                            }
                        }
                    }
                    
                    return null;
                } catch (error) {
                    logError(`Object lookup failed for ${identifier}: ${error.message}`);
                    return null;
                }
            }
            
            getAllWalls() {
                return ['north-wall', 'south-wall', 'east-wall', 'west-wall'];
            }
            
            getPerformanceMetrics() {
                const metrics = { ...this.performanceMetrics };
                
                if (metrics.creationTimes.length > 0) {
                    metrics.avgCreationTime = metrics.creationTimes.reduce((a, b) => a + b) / metrics.creationTimes.length;
                    metrics.maxCreationTime = Math.max(...metrics.creationTimes);
                }
                
                if (metrics.removalTimes.length > 0) {
                    metrics.avgRemovalTime = metrics.removalTimes.reduce((a, b) => a + b) / metrics.removalTimes.length;
                    metrics.maxRemovalTime = Math.max(...metrics.removalTimes);
                }
                
                metrics.successRate = ((metrics.operationCount - metrics.errorCount) / Math.max(1, metrics.operationCount) * 100).toFixed(1);
                
                return metrics;
            }
            
            clearAll(scene) {
                try {
                    let disposed = 0;
                    
                    for (let [key, mesh] of this.createdObjects) {
                        if (mesh.userData.isAdded) { // Only clear user-added items
                            this.safeDispose(mesh);
                            scene.remove(mesh);
                            disposed++;
                        }
                    }
                    
                    // Clear tracking maps
                    this.addedItems.clear();
                    
                    // Keep original room objects
                    const toKeep = new Map();
                    for (let [key, mesh] of this.createdObjects) {
                        if (!mesh.userData.isAdded) {
                            toKeep.set(key, mesh);
                        }
                    }
                    this.createdObjects = toKeep;
                    
                    logSuccess(`Cleared ${disposed} objects safely`);
                    return disposed;
                } catch (error) {
                    logError(`Cleanup failed: ${error.message}`);
                    return 0;
                }
            }
            
            validateIntegrity() {
                let issues = [];
                
                try {
                    // Check for orphaned objects
                    let sceneObjects = 0;
                    scene.traverse((obj) => {
                        if (obj.isMesh) sceneObjects++;
                    });
                    
                    if (sceneObjects !== this.createdObjects.size) {
                        issues.push(`Scene/Registry mismatch: ${sceneObjects} vs ${this.createdObjects.size}`);
                    }
                    
                    // Check for null references
                    for (let [key, mesh] of this.createdObjects) {
                        if (!mesh || !mesh.userData) {
                            issues.push(`Invalid object reference: ${key}`);
                        }
                    }
                    
                    // Check for disposed geometries/materials still in use
                    for (let [key, mesh] of this.createdObjects) {
                        if (mesh.geometry && mesh.geometry.isBufferGeometry === false) {
                            issues.push(`Disposed geometry in use: ${key}`);
                        }
                    }
                    
                    if (issues.length === 0) {
                        logSuccess("Integrity check passed");
                    } else {
                        issues.forEach(issue => logError(`Integrity issue: ${issue}`));
                    }
                    
                    return issues;
                } catch (error) {
                    logError(`Integrity check failed: ${error.message}`);
                    return [`Integrity check crashed: ${error.message}`];
                }
            }
        }

        // Global variables
        const status = document.getElementById('status');
        let factory;
        let scene, camera, renderer;
        let testResults = {
            stressTests: [],
            memoryTests: [],
            errorTests: [],
            performanceTests: []
        };
        
        function updateStatus(message, isError = false) {
            console.log(message);
            const timestamp = new Date().toLocaleTimeString();
            status.innerHTML += `<br>[${timestamp}] ${isError ? '‚ùå' : '‚úÖ'} ${message}`;
        }
        
        function logError(message) {
            const timestamp = new Date().toLocaleTimeString();
            status.innerHTML += `<br><div class="error-info">[${timestamp}] ‚ùå ${message}</div>`;
        }
        
        function logSuccess(message) {
            const timestamp = new Date().toLocaleTimeString();
            status.innerHTML += `<br><div class="success-info">[${timestamp}] ‚úÖ ${message}</div>`;
        }
        
        function logPerformance(message) {
            const timestamp = new Date().toLocaleTimeString();
            status.innerHTML += `<br><div class="performance-info">[${timestamp}] üìä ${message}</div>`;
        }

        // Scene setup
        function initScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf5f5f5);
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(6, 5, 6);
            camera.lookAt(0, 2, 0);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);
            
            // Enhanced lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
            scene.add(ambientLight);
            
            const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.7);
            directionalLight1.position.set(8, 8, 5);
            directionalLight1.castShadow = true;
            scene.add(directionalLight1);
            
            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.3);
            directionalLight2.position.set(-5, 5, -5);
            scene.add(directionalLight2);
            
            window.scene = scene;
            updateStatus("Scene initialized for edge case testing");
        }

        function createInitialRoom() {
            factory = new RobustFactory();
            
            // Create basic room with error handling
            try {
                factory.createdObjects.set('ref-pole', createReferencePole());
                factory.createdObjects.set('debug-ball', createDebugBall());
                factory.createdObjects.set('floor', createFloor());
                
                const walls = createWalls();
                walls.forEach((wall, index) => {
                    const compass = ['north', 'south', 'east', 'west'][index];
                    wall.userData.compass = compass;
                    factory.createdObjects.set(`${compass}-wall`, wall);
                });
                
                updateStatus("Initial room created with error handling");
            } catch (error) {
                logError(`Room creation failed: ${error.message}`);
            }
        }

        function createReferencePole() {
            const geometry = new THREE.CylinderGeometry(0.1, 0.1, 1, 8);
            const material = new THREE.MeshBasicMaterial({ color: 0x000000 });
            const pole = new THREE.Mesh(geometry, material);
            pole.position.set(0, 0.5, 0);
            pole.userData = { id: 'referencePole', componentType: 'referencePole', isAdded: false };
            scene.add(pole);
            return pole;
        }

        function createDebugBall() {
            const geometry = new THREE.SphereGeometry(0.3, 16, 16);
            const material = new THREE.MeshStandardMaterial({ 
                color: 0x44ff44, roughness: 0.3, metalness: 0.2,
                transparent: true, opacity: 0.8, emissive: 0x114411, emissiveIntensity: 0.2
            });
            const ball = new THREE.Mesh(geometry, material);
            ball.position.set(2, 0.3, 1);
            ball.castShadow = true;
            ball.receiveShadow = true;
            ball.userData = { id: 'debugBall', componentType: 'debugBall', isAdded: false };
            scene.add(ball);
            return ball;
        }

        function createFloor() {
            const geometry = new THREE.PlaneGeometry(10, 8);
            const material = new THREE.MeshStandardMaterial({ color: 0x90EE90, roughness: 0.6, metalness: 0.1 });
            const floor = new THREE.Mesh(geometry, material);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            floor.userData = { id: 'floor', componentType: 'floor', isAdded: false };
            scene.add(floor);
            return floor;
        }

        function createWalls() {
            const walls = [];
            const positions = [[0, 4, 4], [0, 4, -4], [5, 4, 0], [-5, 4, 0]];
            const rotations = [[0, Math.PI, 0], [0, 0, 0], [0, -Math.PI/2, 0], [0, Math.PI/2, 0]];
            const sizes = [[10, 8], [10, 8], [8, 8], [8, 8]];
            
            positions.forEach((pos, i) => {
                const geometry = new THREE.PlaneGeometry(...sizes[i]);
                const material = new THREE.MeshStandardMaterial({ color: 0xf8f8f8, roughness: 0.9, metalness: 0.1 });
                const wall = new THREE.Mesh(geometry, material);
                wall.position.set(...pos);
                wall.rotation.set(...rotations[i]);
                wall.receiveShadow = true;
                wall.userData = { id: `wall-${i}`, componentType: 'wall', isAdded: false };
                scene.add(wall);
                walls.push(wall);
            });
            
            return walls;
        }

        // STRESS TESTS
        function stressTestMany() {
            updateStatus("Starting stress test: Adding 50 objects...");
            const startTime = performance.now();
            
            const types = ['cube', 'sphere', 'cylinder'];
            let successCount = 0;
            
            for (let i = 0; i < 50; i++) {
                const type = types[i % types.length];
                const obj = factory.addComponent(type, { scene: scene });
                if (obj) successCount++;
                
                // Yield control periodically
                if (i % 10 === 0) {
                    setTimeout(() => {}, 1);
                }
            }
            
            const elapsed = performance.now() - startTime;
            logPerformance(`Added ${successCount}/50 objects in ${elapsed.toFixed(2)}ms`);
            
            testResults.stressTests.push({
                name: 'Many Objects',
                success: successCount,
                total: 50,
                duration: elapsed
            });
        }
        
        function stressTestRapid() {
            updateStatus("Starting rapid command test...");
            const startTime = performance.now();
            
            const commands = [
                () => factory.addComponent('cube', { scene: scene }),
                () => factory.setColor('cube-1', '#ff0000'),
                () => factory.addComponent('sphere', { scene: scene }),
                () => factory.setColor('north-wall', '#0000ff'),
                () => factory.addComponent('cylinder', { scene: scene })
            ];
            
            let successCount = 0;
            
            // Rapid-fire commands
            commands.forEach((cmd, i) => {
                setTimeout(() => {
                    try {
                        const result = cmd();
                        if (result !== false) successCount++;
                    } catch (error) {
                        logError(`Rapid command ${i} failed: ${error.message}`);
                    }
                }, i * 10); // 10ms intervals
            });
            
            setTimeout(() => {
                const elapsed = performance.now() - startTime;
                logPerformance(`Rapid test: ${successCount}/${commands.length} succeeded in ${elapsed.toFixed(2)}ms`);
                
                testResults.stressTests.push({
                    name: 'Rapid Commands',
                    success: successCount,
                    total: commands.length,
                    duration: elapsed
                });
            }, commands.length * 10 + 100);
        }
        
        function stressTestMemory() {
            updateStatus("Starting memory overload test...");
            const startTime = performance.now();
            
            // Create and destroy objects rapidly
            let created = 0, destroyed = 0;
            
            for (let i = 0; i < 100; i++) {
                const obj = factory.addComponent('cube', { scene: scene });
                if (obj) {
                    created++;
                    
                    // Destroy every other object immediately
                    if (i % 2 === 0) {
                        setTimeout(() => {
                            if (factory.removeComponent(obj.userData.id, scene)) {
                                destroyed++;
                            }
                        }, 10);
                    }
                }
            }
            
            setTimeout(() => {
                const elapsed = performance.now() - startTime;
                logPerformance(`Memory test: Created ${created}, Destroyed ${destroyed} in ${elapsed.toFixed(2)}ms`);
                
                testResults.memoryTests.push({
                    name: 'Memory Overload',
                    created: created,
                    destroyed: destroyed,
                    duration: elapsed
                });
            }, 1000);
        }
        
        function stressTestConcurrent() {
            updateStatus("Starting concurrent operations test...");
            const startTime = performance.now();
            
            const operations = [];
            
            // Schedule multiple operations concurrently
            for (let i = 0; i < 20; i++) {
                operations.push(new Promise((resolve) => {
                    setTimeout(() => {
                        try {
                            const obj = factory.addComponent('sphere', { scene: scene });
                            resolve(obj ? 'success' : 'failed');
                        } catch (error) {
                            resolve('error');
                        }
                    }, Math.random() * 100);
                }));
            }
            
            Promise.all(operations).then(results => {
                const elapsed = performance.now() - startTime;
                const successes = results.filter(r => r === 'success').length;
                
                logPerformance(`Concurrent test: ${successes}/20 operations succeeded in ${elapsed.toFixed(2)}ms`);
                
                testResults.stressTests.push({
                    name: 'Concurrent Operations',
                    success: successes,
                    total: 20,
                    duration: elapsed
                });
            });
        }

        // MEMORY MANAGEMENT TESTS
        function testMemoryLeaks() {
            updateStatus("Testing for memory leaks...");
            
            const initialObjects = factory.createdObjects.size;
            const objects = [];
            
            // Create objects
            for (let i = 0; i < 20; i++) {
                const obj = factory.addComponent('cube', { scene: scene });
                if (obj) objects.push(obj.userData.id);
            }
            
            // Remove all objects
            objects.forEach(id => {
                factory.removeComponent(id, scene);
            });
            
            const finalObjects = factory.createdObjects.size;
            
            if (finalObjects === initialObjects) {
                logSuccess("Memory leak test passed - all objects properly cleaned up");
            } else {
                logError(`Memory leak detected: ${finalObjects - initialObjects} objects not cleaned up`);
            }
            
            testResults.memoryTests.push({
                name: 'Memory Leaks',
                passed: finalObjects === initialObjects,
                leaked: finalObjects - initialObjects
            });
        }
        
        function testGarbageCollection() {
            updateStatus("Testing garbage collection...");
            
            // Create disposable objects
            const disposables = [];
            for (let i = 0; i < 10; i++) {
                const geometry = new THREE.BoxGeometry(1, 1, 1);
                const material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                disposables.push({ geometry, material });
            }
            
            // Dispose all
            disposables.forEach(({ geometry, material }) => {
                geometry.dispose();
                material.dispose();
            });
            
            // Force garbage collection if available
            if (window.gc) {
                window.gc();
                logSuccess("Forced garbage collection");
            } else {
                logSuccess("Garbage collection test completed (gc not available)");
            }
            
            testResults.memoryTests.push({
                name: 'Garbage Collection',
                disposed: disposables.length,
                forced: !!window.gc
            });
        }
        
        function testLargeObjects() {
            updateStatus("Testing large object handling...");
            
            try {
                // Try to create an object with very large geometry
                const largeGeometry = new THREE.SphereGeometry(50, 100, 100);
                const largeMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
                const largeMesh = new THREE.Mesh(largeGeometry, largeMaterial);
                
                largeMesh.position.set(0, 25, 0);
                scene.add(largeMesh);
                
                // Test if it renders properly
                setTimeout(() => {
                    scene.remove(largeMesh);
                    largeGeometry.dispose();
                    largeMaterial.dispose();
                    logSuccess("Large object test passed");
                }, 1000);
                
                testResults.memoryTests.push({
                    name: 'Large Objects',
                    passed: true
                });
                
            } catch (error) {
                logError(`Large object test failed: ${error.message}`);
                testResults.memoryTests.push({
                    name: 'Large Objects',
                    passed: false,
                    error: error.message
                });
            }
        }
        
        function cleanupTest() {
            updateStatus("Testing cleanup procedures...");
            
            const beforeCount = factory.createdObjects.size;
            const cleaned = factory.clearAll(scene);
            const afterCount = factory.createdObjects.size;
            
            logPerformance(`Cleanup test: Removed ${cleaned} objects, ${beforeCount} -> ${afterCount} objects`);
            
            testResults.memoryTests.push({
                name: 'Cleanup Test',
                removed: cleaned,
                before: beforeCount,
                after: afterCount
            });
        }

        // ERROR CONDITION TESTS
        function testInvalidCommands() {
            updateStatus("Testing invalid command handling...");
            
            const invalidTests = [
                () => factory.addComponent('nonexistent', { scene: scene }),
                () => factory.addComponent('cube', { position: [NaN, 0, 0], scene: scene }),
                () => factory.addComponent('cube', { position: 'invalid', scene: scene }),
                () => factory.removeComponent('does-not-exist', scene),
                () => factory.setColor('missing-object', '#ff0000')
            ];
            
            let errorsCaught = 0;
            
            invalidTests.forEach((test, i) => {
                try {
                    const result = test();
                    if (result === false || result === null) {
                        errorsCaught++;
                    }
                } catch (error) {
                    errorsCaught++;
                }
            });
            
            logPerformance(`Invalid command test: ${errorsCaught}/${invalidTests.length} errors properly handled`);
            
            testResults.errorTests.push({
                name: 'Invalid Commands',
                handled: errorsCaught,
                total: invalidTests.length
            });
        }
        
        function testMissingObjects() {
            updateStatus("Testing missing object handling...");
            
            const missingTests = [
                'nonexistent-object',
                'deleted-object',
                null,
                undefined,
                ''
            ];
            
            let errorsCaught = 0;
            
            missingTests.forEach(identifier => {
                try {
                    const result = factory.findObject(identifier);
                    if (result === null) {
                        errorsCaught++; // Correctly returned null
                    }
                } catch (error) {
                    errorsCaught++; // Properly caught error
                }
            });
            
            logPerformance(`Missing object test: ${errorsCaught}/${missingTests.length} cases handled correctly`);
            
            testResults.errorTests.push({
                name: 'Missing Objects',
                handled: errorsCaught,
                total: missingTests.length
            });
        }
        
        function testCorruptedData() {
            updateStatus("Testing corrupted data handling...");
            
            let errorsCaught = 0;
            
            // Test with corrupted material data
            try {
                const corruptedMaterial = {
                    type: 'InvalidMaterialType',
                    color: 'not-a-color',
                    roughness: 'text-instead-of-number',
                    metalness: Infinity
                };
                
                const material = factory.createMaterial(corruptedMaterial);
                if (material) {
                    errorsCaught++; // Successfully created fallback material
                }
            } catch (error) {
                errorsCaught++; // Properly caught error
            }
            
            // Test with corrupted geometry data
            try {
                const geometry = factory.createGeometry('invalid-type', ['a', 'b', 'c']);
                if (geometry) {
                    errorsCaught++; // Successfully created fallback geometry
                }
            } catch (error) {
                errorsCaught++; // Properly caught error
            }
            
            logPerformance(`Corrupted data test: ${errorsCaught}/2 cases handled correctly`);
            
            testResults.errorTests.push({
                name: 'Corrupted Data',
                handled: errorsCaught,
                total: 2
            });
        }
        
        function testBoundaryValues() {
            updateStatus("Testing boundary value handling...");
            
            const boundaryTests = [
                { position: [1000, 1000, 1000] }, // Very large coordinates
                { position: [-1000, -1000, -1000] }, // Very negative coordinates
                { position: [0.000001, 0.000001, 0.000001] }, // Very small coordinates
                { position: [Infinity, 0, 0] }, // Infinity values
                { position: [-Infinity, 0, 0] } // Negative infinity
            ];
            
            let handled = 0;
            
            boundaryTests.forEach(test => {
                const obj = factory.addComponent('cube', { ...test, scene: scene });
                if (obj) {
                    // Check if position was clamped/corrected
                    const pos = obj.position;
                    if (isFinite(pos.x) && isFinite(pos.y) && isFinite(pos.z)) {
                        handled++;
                    }
                }
            });
            
            logPerformance(`Boundary value test: ${handled}/${boundaryTests.length} values handled correctly`);
            
            testResults.errorTests.push({
                name: 'Boundary Values',
                handled: handled,
                total: boundaryTests.length
            });
        }

        // PERFORMANCE TESTS
        function benchmarkOperations() {
            updateStatus("Benchmarking operations...");
            
            const iterations = 100;
            const results = {
                creation: [],
                removal: [],
                colorChange: []
            };
            
            // Benchmark creation
            for (let i = 0; i < iterations; i++) {
                const start = performance.now();
                const obj = factory.addComponent('cube', { scene: scene });
                const elapsed = performance.now() - start;
                
                if (obj) {
                    results.creation.push(elapsed);
                }
            }
            
            // Benchmark removal
            const objects = Array.from(factory.addedItems.keys()).slice(0, 50);
            objects.forEach(id => {
                const start = performance.now();
                factory.removeComponent(id, scene);
                const elapsed = performance.now() - start;
                results.removal.push(elapsed);
            });
            
            // Benchmark color changes
            for (let i = 0; i < 50; i++) {
                const start = performance.now();
                factory.setColor('north-wall', `#${Math.floor(Math.random()*16777215).toString(16)}`);
                const elapsed = performance.now() - start;
                results.colorChange.push(elapsed);
            }
            
            // Calculate statistics
            const stats = {};
            Object.entries(results).forEach(([op, times]) => {
                if (times.length > 0) {
                    stats[op] = {
                        avg: (times.reduce((a, b) => a + b) / times.length).toFixed(3),
                        min: Math.min(...times).toFixed(3),
                        max: Math.max(...times).toFixed(3),
                        count: times.length
                    };
                }
            });
            
            logPerformance(`Benchmark results:`);
            Object.entries(stats).forEach(([op, stat]) => {
                logPerformance(`${op}: avg=${stat.avg}ms, min=${stat.min}ms, max=${stat.max}ms (n=${stat.count})`);
            });
            
            testResults.performanceTests.push({
                name: 'Operation Benchmark',
                results: stats
            });
        }
        
        function profileRendering() {
            updateStatus("Profiling rendering performance...");
            
            const startObjects = scene.children.length;
            const frameRates = [];
            let lastTime = performance.now();
            let frameCount = 0;
            
            // Add objects and measure frame rate impact
            for (let i = 0; i < 20; i++) {
                factory.addComponent('cube', { scene: scene });
            }
            
            // Measure frame rate for 2 seconds
            const measureFrameRate = () => {
                const now = performance.now();
                const delta = now - lastTime;
                
                if (delta >= 1000) { // Every second
                    const fps = (frameCount / delta) * 1000;
                    frameRates.push(fps);
                    frameCount = 0;
                    lastTime = now;
                    
                    if (frameRates.length >= 3) {
                        const avgFPS = (frameRates.reduce((a, b) => a + b) / frameRates.length).toFixed(1);
                        const endObjects = scene.children.length;
                        
                        logPerformance(`Rendering profile: ${avgFPS} FPS average with ${endObjects} objects (was ${startObjects})`);
                        
                        testResults.performanceTests.push({
                            name: 'Rendering Profile',
                            avgFPS: parseFloat(avgFPS),
                            objectsBefore: startObjects,
                            objectsAfter: endObjects
                        });
                        
                        return;
                    }
                }
                
                frameCount++;
                requestAnimationFrame(measureFrameRate);
            };
            
            requestAnimationFrame(measureFrameRate);
        }
        
        function testScalability() {
            updateStatus("Testing scalability...");
            
            const scales = [10, 50, 100, 200];
            const results = [];
            
            let currentScale = 0;
            
            const testScale = (objectCount) => {
                const startTime = performance.now();
                let created = 0;
                
                for (let i = 0; i < objectCount; i++) {
                    const obj = factory.addComponent('sphere', { scene: scene });
                    if (obj) created++;
                }
                
                const elapsed = performance.now() - startTime;
                
                results.push({
                    objectCount: objectCount,
                    created: created,
                    duration: elapsed,
                    avgPerObject: (elapsed / created).toFixed(3)
                });
                
                logPerformance(`Scale ${objectCount}: Created ${created} objects in ${elapsed.toFixed(2)}ms (${(elapsed/created).toFixed(3)}ms each)`);
                
                // Clean up for next test
                factory.clearAll(scene);
                
                currentScale++;
                if (currentScale < scales.length) {
                    setTimeout(() => testScale(scales[currentScale]), 500);
                } else {
                    testResults.performanceTests.push({
                        name: 'Scalability Test',
                        results: results
                    });
                }
            };
            
            testScale(scales[currentScale]);
        }
        
        function measureLatency() {
            updateStatus("Measuring operation latency...");
            
            const operations = [
                { name: 'Add Object', op: () => factory.addComponent('cube', { scene: scene }) },
                { name: 'Find Object', op: () => factory.findObject('north-wall') },
                { name: 'Change Color', op: () => factory.setColor('north-wall', '#ff0000') },
                { name: 'Remove Object', op: () => {
                    const obj = factory.addComponent('cube', { scene: scene });
                    return obj ? factory.removeComponent(obj.userData.id, scene) : false;
                }}
            ];
            
            const latencies = {};
            
            operations.forEach(({ name, op }) => {
                const times = [];
                
                for (let i = 0; i < 50; i++) {
                    const start = performance.now();
                    try {
                        op();
                    } catch (error) {
                        // Continue measuring even if operation fails
                    }
                    const elapsed = performance.now() - start;
                    times.push(elapsed);
                }
                
                latencies[name] = {
                    avg: (times.reduce((a, b) => a + b) / times.length).toFixed(3),
                    p95: times.sort((a, b) => a - b)[Math.floor(times.length * 0.95)].toFixed(3),
                    p99: times.sort((a, b) => a - b)[Math.floor(times.length * 0.99)].toFixed(3)
                };
                
                logPerformance(`${name}: avg=${latencies[name].avg}ms, p95=${latencies[name].p95}ms, p99=${latencies[name].p99}ms`);
            });
            
            testResults.performanceTests.push({
                name: 'Latency Measurement',
                latencies: latencies
            });
        }

        // RECOVERY & VALIDATION
        function testStateRecovery() {
            updateStatus("Testing state recovery...");
            
            // Create some objects
            const objects = [];
            for (let i = 0; i < 5; i++) {
                const obj = factory.addComponent('cube', { scene: scene });
                if (obj) objects.push(obj.userData.id);
            }
            
            // Simulate corruption by directly manipulating scene
            const corruptedObject = scene.children.find(child => 
                child.userData && objects.includes(child.userData.id)
            );
            
            if (corruptedObject) {
                // Simulate corruption
                scene.remove(corruptedObject);
                
                // Test recovery
                const issues = factory.validateIntegrity();
                
                if (issues.length > 0) {
                    logSuccess("State corruption detected successfully");
                    
                    // Attempt recovery by cleaning up orphaned references
                    factory.createdObjects.delete(corruptedObject.userData.id);
                    factory.addedItems.delete(corruptedObject.userData.id);
                    
                    const postRecovery = factory.validateIntegrity();
                    
                    if (postRecovery.length === 0) {
                        logSuccess("State recovery successful");
                    } else {
                        logError("State recovery failed");
                    }
                } else {
                    logError("State corruption not detected");
                }
            }
        }
        
        function validateIntegrity() {
            updateStatus("Validating system integrity...");
            const issues = factory.validateIntegrity();
            
            if (issues.length === 0) {
                logSuccess("System integrity validation passed");
            } else {
                logError(`System integrity issues found: ${issues.length}`);
                issues.forEach(issue => logError(`  - ${issue}`));
            }
            
            return issues;
        }
        
        function testRollback() {
            updateStatus("Testing rollback capability...");
            
            const beforeState = {
                objectCount: factory.createdObjects.size,
                sceneChildren: scene.children.length
            };
            
            // Make some changes
            const added = [];
            for (let i = 0; i < 3; i++) {
                const obj = factory.addComponent('cube', { scene: scene });
                if (obj) added.push(obj.userData.id);
            }
            
            // "Rollback" by removing added objects
            let rolledBack = 0;
            added.forEach(id => {
                if (factory.removeComponent(id, scene)) {
                    rolledBack++;
                }
            });
            
            const afterState = {
                objectCount: factory.createdObjects.size,
                sceneChildren: scene.children.length
            };
            
            if (beforeState.objectCount === afterState.objectCount &&
                beforeState.sceneChildren === afterState.sceneChildren) {
                logSuccess(`Rollback test passed: restored to original state (${rolledBack} operations rolled back)`);
            } else {
                logError(`Rollback test failed: state not properly restored`);
            }
        }
        
        function emergencyCleanup() {
            updateStatus("Performing emergency cleanup...");
            
            try {
                const beforeObjects = scene.children.length;
                
                // Force cleanup of all disposable objects
                scene.traverse((object) => {
                    if (object.isMesh && object.userData && object.userData.isAdded) {
                        if (object.geometry && object.geometry.dispose) {
                            object.geometry.dispose();
                        }
                        if (object.material && object.material.dispose) {
                            object.material.dispose();
                        }
                    }
                });
                
                // Remove all added objects from scene
                const toRemove = [];
                scene.traverse((object) => {
                    if (object.isMesh && object.userData && object.userData.isAdded) {
                        toRemove.push(object);
                    }
                });
                
                toRemove.forEach(obj => scene.remove(obj));
                
                // Clear factory tracking
                factory.addedItems.clear();
                const keepObjects = new Map();
                for (let [key, mesh] of factory.createdObjects) {
                    if (!mesh.userData.isAdded) {
                        keepObjects.set(key, mesh);
                    }
                }
                factory.createdObjects = keepObjects;
                
                const afterObjects = scene.children.length;
                
                logSuccess(`Emergency cleanup complete: removed ${beforeObjects - afterObjects} objects`);
                
                // Force garbage collection if available
                if (window.gc) {
                    window.gc();
                    logSuccess("Forced garbage collection after cleanup");
                }
                
            } catch (error) {
                logError(`Emergency cleanup failed: ${error.message}`);
            }
        }

        // REPORTING
        function generateReport() {
            updateStatus("Generating comprehensive test report...");
            
            const metrics = factory.getPerformanceMetrics();
            
            logPerformance("=== COMPREHENSIVE TEST REPORT ===");
            
            // Performance Metrics
            logPerformance(`Total Operations: ${metrics.operationCount}`);
            logPerformance(`Success Rate: ${metrics.successRate}%`);
            logPerformance(`Error Count: ${metrics.errorCount}`);
            
            if (metrics.avgCreationTime) {
                logPerformance(`Avg Creation Time: ${metrics.avgCreationTime.toFixed(3)}ms`);
                logPerformance(`Max Creation Time: ${metrics.maxCreationTime.toFixed(3)}ms`);
            }
            
            if (metrics.avgRemovalTime) {
                logPerformance(`Avg Removal Time: ${metrics.avgRemovalTime.toFixed(3)}ms`);
                logPerformance(`Max Removal Time: ${metrics.maxRemovalTime.toFixed(3)}ms`);
            }
            
            // Test Results Summary
            logPerformance("=== TEST RESULTS SUMMARY ===");
            
            Object.entries(testResults).forEach(([category, tests]) => {
                if (tests.length > 0) {
                    logPerformance(`${category.toUpperCase()}: ${tests.length} tests`);
                    tests.forEach((test, i) => {
                        logPerformance(`  ${i+1}. ${test.name}: ${JSON.stringify(test).substring(0, 80)}...`);
                    });
                }
            });
            
            // Current Scene State
            logPerformance("=== SCENE STATE ===");
            logPerformance(`Scene Objects: ${scene.children.length}`);
            logPerformance(`Tracked Objects: ${factory.createdObjects.size}`);
            logPerformance(`Added Objects: ${factory.addedItems.size}`);
            
            const issues = factory.validateIntegrity();
            if (issues.length === 0) {
                logSuccess("System integrity: HEALTHY");
            } else {
                logError(`System integrity: ${issues.length} ISSUES`);
            }
            
            logPerformance("=== REPORT COMPLETE ===");
        }

        // UI FUNCTIONS
        function resetEverything() {
            // Clear all test results
            testResults = {
                stressTests: [],
                memoryTests: [],
                errorTests: [],
                performanceTests: []
            };
            
            // Clear log
            document.getElementById('status').innerHTML = '';
            
            // Emergency cleanup
            emergencyCleanup();
            
            // Reinitialize
            setTimeout(() => {
                createInitialRoom();
                updateStatus("System completely reset");
            }, 500);
        }
        
        function toggleInfo() {
            const info = document.getElementById('info');
            const toggle = document.getElementById('toggle-info');
            if (info.style.display === 'none') {
                info.style.display = 'block';
                toggle.textContent = 'HIDE INFO';
            } else {
                info.style.display = 'none';
                toggle.textContent = 'SHOW INFO';
            }
        }

        // INITIALIZATION
        setTimeout(() => {
            if (typeof THREE !== 'undefined') {
                updateStatus(`THREE.js loaded (r${THREE.REVISION})`);
                initScene();
                createInitialRoom();
                updateStatus("‚ö†Ô∏è EDGE CASES & ERROR HANDLING TEST READY");
                updateStatus("Use the buttons to test system robustness!");
            } else {
                updateStatus("‚ùå THREE.js failed to load", true);
            }
        }, 1000);
        
        // Render loop with error handling
        function animate() {
            try {
                requestAnimationFrame(animate);
                renderer.render(scene, camera);
            } catch (error) {
                logError(`Render error: ${error.message}`);
                // Continue anyway
                requestAnimationFrame(animate);
            }
        }
        animate();

        // Mouse controls with error handling
        let mouseX = 0, mouseY = 0;
        document.addEventListener('mousemove', (e) => {
            try {
                mouseX = (e.clientX / window.innerWidth) * 2 - 1;
                mouseY = -(e.clientY / window.innerHeight) * 2 + 1;
                
                const radius = 8;
                camera.position.x = Math.cos(mouseX * Math.PI) * radius;
                camera.position.z = Math.sin(mouseX * Math.PI) * radius;
                camera.position.y = 3 + mouseY * 3;
                camera.lookAt(0, 2, 0);
            } catch (error) {
                // Silently handle mouse control errors
            }
        });

        // Global error handler
        window.addEventListener('error', (event) => {
            logError(`Global error: ${event.message} at ${event.filename}:${event.lineno}`);
        });

        window.addEventListener('unhandledrejection', (event) => {
            logError(`Unhandled promise rejection: ${event.reason}`);
        });
    </script>
</body>
</html>